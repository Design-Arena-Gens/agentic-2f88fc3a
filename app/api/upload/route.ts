import { NextRequest, NextResponse } from "next/server";
import path from "node:path";
import fs from "node:fs/promises";
import { tmpdir } from "node:os";
import { google } from "googleapis";
import { randomUUID } from "node:crypto";

export const runtime = "nodejs";
export const maxDuration = 300;

export async function POST(request: NextRequest) {
  let tempVideoPath: string | undefined;

  try {
    const form = await request.formData();
    const file = form.get("file");
    const title = getString(form.get("title")) ?? "India News Briefing";
    const description =
      getString(form.get("description")) ??
      "Automated upload generated by the India Update Generator.";
    const tags = parseTags(form.get("tags"));

    const clientId = getString(form.get("clientId"));
    const clientSecret = getString(form.get("clientSecret"));
    const refreshToken = getString(form.get("refreshToken"));
    const accessToken = getString(form.get("accessToken"));

    if (!(file instanceof File)) {
      return NextResponse.json(
        { error: "Video file missing from request payload." },
        { status: 400 }
      );
    }

    if (!clientId || !clientSecret || !refreshToken) {
      return NextResponse.json(
        {
          error:
            "YouTube OAuth credentials are required (client ID, client secret, refresh token).",
        },
        { status: 400 }
      );
    }

    const buffer = Buffer.from(await file.arrayBuffer());
    const tempDirectory = path.join(tmpdir(), `yt-upload-${randomUUID()}`);
    await fs.mkdir(tempDirectory, { recursive: true });
    tempVideoPath = path.join(tempDirectory, "upload.mp4");
    await fs.writeFile(tempVideoPath, buffer);

    const oauth2Client = new google.auth.OAuth2(clientId, clientSecret);
    oauth2Client.setCredentials({
      refresh_token: refreshToken,
      access_token: accessToken ?? undefined,
    });

    const youtube = google.youtube({
      version: "v3",
      auth: oauth2Client,
    });

    const uploadResponse = await youtube.videos.insert({
      part: ["snippet", "status"],
      requestBody: {
        snippet: {
          title,
          description,
          tags,
          defaultLanguage: "en",
          categoryId: "25", // News & Politics
        },
        status: {
          privacyStatus: "public",
        },
      },
      media: {
        body: (await import("node:fs")).createReadStream(tempVideoPath),
      },
    });

    const videoId = uploadResponse.data.id;
    if (!videoId) {
      throw new Error("YouTube API did not return a video ID.");
    }

    const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

    return NextResponse.json({
      videoId,
      youtubeUrl,
    });
  } catch (error) {
    console.error("[upload-video]", error);
    return NextResponse.json(
      {
        error:
          error instanceof Error
            ? error.message
            : "Failed to upload the video to YouTube.",
      },
      { status: 500 }
    );
  } finally {
    if (tempVideoPath) {
      const directory = path.dirname(tempVideoPath);
      await fs.rm(directory, { recursive: true, force: true });
    }
  }
}

function getString(value: FormDataEntryValue | null): string | undefined {
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }
  return undefined;
}

function parseTags(value: FormDataEntryValue | null): string[] | undefined {
  if (typeof value !== "string" || value.trim().length === 0) {
    return undefined;
  }

  try {
    const parsed = JSON.parse(value);
    if (Array.isArray(parsed)) {
      return parsed
        .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
        .filter((entry) => entry.length > 0);
    }
    return undefined;
  } catch {
    return value
      .split(",")
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0);
  }
}
